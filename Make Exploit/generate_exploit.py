#!/usr/bin/env python3

from jinja2 import Template
from pwn import *
import sys
import argparse
import json
from ropper import RopperService
import subprocess

args = ''
binary_name = ''
binary_file = ''
binary_arch = ''
binary_static = 0
binary_plt = ''
binary_got = ''
binary_rop = ''
library_name = ''
library_file = ''
library_magic = ''
library_offsets = ''
library_oneg = ''
library_rop = ''
section_header = "# ============================================================== #\n"
section_header += "# ================= OFFSETS & GADGETS & MAGIC ================== #\n"
section_header += "# ============================================================== #\n"
lookup_table = []
remote_addr = ''
remote_port = None
exploit = ''

# =============================
# ROUTINES
# =============================

def get_gadgets( executable_name ):
    global binary_arch
    
    arch = ''
    if binary_arch == 'amd64':
        arch = 'x86_64'
    elif binary_arch == 'i386':
        arch = 'x86'
    else:
        log.failure('Unknown arch')
        exit()

    options = {
        'color' : False, 
        'badbytes': '00',  
        'all' : False,      
        'inst_count' : 6,  
        'type' : 'all',    
        'detailed' : False
    }
    rs = RopperService(options)
    rs.addFile(executable_name, bytes=open(executable_name,'rb').read(), raw=True, arch=arch)
    rs.options.badbytes = ''
    rs.options.all = True
    rs.loadGadgetsFor()
    rs.options.type = 'rop'
    rs.loadGadgetsFor()
    gags = []

    if binary_arch == 'amd64':
        for i in rs.search(search='pop r?i', name=executable_name):
            gags.append(str(i[1]))
        for i in rs.search(search='pop r?x', name=executable_name):
            gags.append(str(i[1]))
        for i in rs.search(search='pop r?p', name=executable_name):
            gags.append(str(i[1]))
        for i in rs.search(search='syscall', name=executable_name):
            gags.append(str(i[1])); break
        for i in rs.search(search='leave', name=executable_name):
            gags.append(str(i[1])); break
    else:
        for i in rs.search(search='pop e?x', name=executable_name):
            gags.append(str(i[1]))
        for i in rs.search(search='pop e?p', name=executable_name):
            gags.append(str(i[1]))
        for i in rs.search(search='int 0x80', name=executable_name):
            gags.append(str(i[1])); break
        for i in rs.search(search='leave', name=executable_name):
            gags.append(str(i[1])); break

    return gags


def extract_binary_plt():
    global binary_plt
    global lookup_table
    plt_table = binary_file.plt

    binary_plt = '\n# ============ PLT =========== #\n\n'
    for key, value in plt_table.items():
        binary_plt += key + '_PLT = ' + hex(value) + '\n'
        
        lookup_table.append(key)
        if key == 'system':
            log.info("System function detected in binary!")
        if key == 'execve':
            log.info("Execve function detected in binary!")

    
def extract_binary_got():
    global binary_got
    got_table = binary_file.got

    binary_got = '\n# ============ GOT =========== #\n\n'
    for key, value in got_table.items():
        binary_got += key + '_GOT = ' + hex(value) + '\n'


def open_binary( binn ):
    global binary_file
    global binary_name
    global binary_arch
    global binary_static
    global binary_rop
    log.info("Opening Binary")

    binary_name = binn
    try:
        binary_file = ELF(binary_name)
        binary_arch = binary_file.get_machine_arch()
        if binary_file.statically_linked == True:
            binary_static = 1
        extract_binary_plt()
        extract_binary_got()

        binary_gadgets = get_gadgets(binary_name)
        binary_rop = '\n# ============ BINARY GADGETS =========== #\n\n'
        for i in binary_gadgets:
            binary_rop += i.split(' ')[1].replace(';','') + '_' + i.split(' ')[2].replace(';','') + ' = ' + i.replace(': ',' # ') + '\n'

    except:
        log.failure("Error opening the binary file")
        exit()


def one_gadget(filename):
    return map(int, subprocess.check_output(['one_gadget', '--raw', filename]).decode("utf-8").split(' '))


def link_library( lib ):
    global library_file
    global library_name
    global lookup_table
    global library_offsets
    global library_magic
    global library_oneg
    log.info("Linking Library")

    library_name = lib
    try:
        library_file = ELF(library_name)
        
        library_offsets = '\n# ============ LIBC OFFSETS =========== #\n\n'
        for i in lookup_table:
            try:
                offset = library_file.symbols[i]
                library_offsets += i + '_off = ' + hex(offset) + '\n'
            except:
                pass

        library_magic = '\n# ============ MAGIC =========== #\n\n'
        library_magic += 'mal_hook_off = ' + hex(library_file.symbols['__malloc_hook']) + '\n' 
        library_magic += 'free_hook_off = ' + hex(library_file.symbols['__free_hook']) + '\n'
        library_magic += 'system_off = ' + hex(library_file.symbols['system']) + '\n'
        library_magic += 'binsh_off = ' + hex(next(library_file.search(b"/bin/sh"))) + '\n'

        library_oneg = '\n# ============ ONE GADGETS =========== #\n\n'
        library_oneg += 'one_gag = [ '

        offsets = list(one_gadget(library_name))
        log.info("Gadgets:" + str(offsets))
        for i in offsets:
            library_oneg += hex(i) + ', '
        library_oneg += '0 ] \n'

    except:
        log.failure("Error linking the library")
        exit()


def link_remote( ip, p ):
    global remote_addr
    global remote_port
    log.info("Linking Remote End")

    remote_addr = ip
    remote_port = p


# =============================
# HANDLE PROGRAM ANALYSIS
# =============================

if __name__ == "__main__":

    parser = argparse.ArgumentParser(description="Exploit the bins.")
    parser.add_argument('-b', help="Specify the name of the binary")
    parser.add_argument('-l', help="Specify the name of the library")
    parser.add_argument('-ip', help="Specify the remote ip")
    parser.add_argument('-p', help="Specify the remote port")
    args = vars(parser.parse_args())
    # print(args)


    #
    #   If the binary is supplied, open it for analysis
    #   Otherwise, generate an empty exploit script
    #
    if args['b'] is not None:
        open_binary( args['b'] )
    else:
        exit()


    #
    #   If the library is supplied, open it for analysis
    #   Otherwise, link system's default library
    #
    if args['l'] is not None:
        link_library(args['l'])
    else:
        if binary_arch == "amd64":
            library_name = "/lib/x86_64-linux-gnu/libc.so.6"
        elif binary_arch == "i386":
            library_name = "/lib/i386-linux-gnu/libc.so.6"
        else:
            log.failure("Unknown Arch")
            exit()
        
        library_file = ELF(library_name)
        link_library(library_name)
        log.info("No Library specified, using system's library: " + library_name)


    #
    #   If the remote end is supplied, link it to exploit script
    #
    if args['ip'] is not None and args['p'] is not None:
        link_remote(args['ip'], args['p'])
    elif args['p']:
        link_remote('127.0.0.1', args['p']) # default ip
    elif args['ip']:
        link_remote(args['ip'], '1337') # default pott

    #
    #   Write Exploit Script to file
    #
    exploit = open("/mnt/c/work/GITHUB/Make Exploit/solve_binaries.py",'r').read()
    t = Template(exploit)

    script = t.render(
        SC_binary_arch = binary_arch,
        SC_word_sz = 64 if binary_arch == "amd64" else 32,
        SC_binary_name = binary_name,
        SC_remote_ip = remote_addr,
        SC_remote_port = remote_port,
        SC_lib_name = library_name,
        SC_extras_section = section_header + binary_plt + binary_got + binary_rop + library_offsets + library_magic + library_oneg
    )

    f = open('./exploit.py','w')
    f.write(script)